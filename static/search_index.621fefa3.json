[{"id":1,"title":"Markdown","content":"#\n\n\n标题语法#\n\n\n> Heading level 1\n> \n> \n> Heading level 2\n\n\n强调语法#\n\n粗体bold text\n\n斜体italicized text\n\n\n引用语法#\n\n> 饮用\n> \n> > 嵌套块饮用\n\n\n列表语法#\n\n 1. First item\n 2. Second item\n 3. Third item\n 4. Fourth item\n\n * First item\n * Second item\n * Third item\n * Fourth item\n\n\n代码语法#\n\nUse code in your Markdown file.\n\nUse code in your Markdown file.\n\n\n分割线语法#\n\n--------------------------------------------------------------------------------\n\n--------------------------------------------------------------------------------\n\n--------------------------------------------------------------------------------\n\n\n链接语法#\n\n百度\n\nhttps://baidu.com\n\n\n图片语法#\n\n\n\n\n表格#\n\nSYNTAX      DESCRIPTION\nHeader      Title\nParagraph   Text\n\n\n代码块#\n\n\n\n\n脚注#\n\nHere's a sentence with a footnote. 1\n\n\n标题编号#\n\n\nMy Great Heading#\n\n\n定义列表#\n\nterm : definition\n\n\n删除线#\n\n删除线\n\n\n任务列表#\n\n * Write the press release\n * Update the website\n * Contact the media\n\n\nFootnotes\n\n 1. This is the footnote. ↩","routePath":"/markdown/","lang":"","toc":[{"text":"标题语法","id":"标题语法","depth":2,"charIndex":3},{"text":"强调语法","id":"强调语法","depth":2,"charIndex":55},{"text":"引用语法","id":"引用语法","depth":2,"charIndex":95},{"text":"列表语法","id":"列表语法","depth":2,"charIndex":122},{"text":"代码语法","id":"代码语法","depth":2,"charIndex":252},{"text":"分割线语法","id":"分割线语法","depth":2,"charIndex":326},{"text":"链接语法","id":"链接语法","depth":2,"charIndex":581},{"text":"图片语法","id":"图片语法","depth":2,"charIndex":612},{"text":"表格","id":"表格","depth":2,"charIndex":622},{"text":"代码块","id":"代码块","depth":2,"charIndex":688},{"text":"脚注","id":"脚注","depth":2,"charIndex":697},{"text":"标题编号","id":"标题编号","depth":2,"charIndex":741},{"text":"My Great Heading","id":"custom-id","depth":3,"charIndex":749},{"text":"定义列表","id":"定义列表","depth":2,"charIndex":769},{"text":"删除线","id":"删除线","depth":2,"charIndex":796},{"text":"任务列表","id":"任务列表","depth":2,"charIndex":808}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"package 使用指南","content":"#\n\npackage.json 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn\n存储所有已安装软件包的名称和版本的地方。\n\n\npackage属性#\n\n\nversion#\n\n\n\n\n\n\n获取package属性#\n\nnpm 脚本有一个非常强大的功能，就是可以使用npm的内部变量\n首先，通过npm_package_前缀，npm脚本可以拿到package.json里面的字段，比如，下面是一个package.json\n\n\n\n那么，变量npm_package_name返回jd-web-rigger，变量npm_package_version返回1.0.0\n\n\n\n\nFront Matter#\n\nYou can add Front Matter at the beginning of your Markdown file, which is a\nYAML-formatted object that defines some metadata. For example:\n\n\n\n> Note: By default, Rspress uses h1 headings as html headings.\n\nYou can also access properties defined in Front Matter in the body, for example:\n\n\n\nThe previously defined properties will be passed to the component as frontmatter\nproperties. So the final output will be:\n\n\n\n\nCustom Container#\n\nYou can use the ::: syntax to create custom containers and support custom\ntitles. For example:\n\nInput:\n\n\n\nOutput:\n\nTIP\n\nThis is a block of type tip\n\nINFO\n\nThis is a block of type info\n\nWARNING\n\nThis is a block of type warning\n\nDANGER\n\nThis is a block of type danger\n\nDETAILS\n\nThis is a block of type details\n\nCustom Title\n\nThis is a block of Custom Title\n\nCustom Title\n\nThis is a block of Custom Title\n\n\nCode Block#\n\n\nBasic Usage#\n\nYou can use the ``` syntax to create code blocks and support custom titles. For\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\n\n\nShow Line Numbers#\n\nIf you want to display line numbers, you can enable the showLineNumbers option\nin the config file:\n\n\n\n\nWrap Code#\n\nIf you want to wrap long code line by default, you can enable the\ndefaultWrapCode option in the config file:\n\n\n\n\nLine Highlighting#\n\nYou can also apply line highlighting and code block title at the same time, for\nexample:\n\nInput:\n\n\n\nOuput:\n\n\n\n\nRustify MDX compiler#\n\nYou can enable Rustify MDX compiler by following config:","routePath":"/note/","lang":"","toc":[{"text":"package属性","id":"package属性","depth":2,"charIndex":96},{"text":"version","id":"version","depth":3,"charIndex":109},{"text":"获取package属性","id":"获取package属性","depth":2,"charIndex":124},{"text":"Front Matter","id":"front-matter","depth":2,"charIndex":311},{"text":"Custom Container","id":"custom-container","depth":2,"charIndex":742},{"text":"Code Block","id":"code-block","depth":2,"charIndex":1165},{"text":"Basic Usage","id":"basic-usage","depth":3,"charIndex":1179},{"text":"Show Line Numbers","id":"show-line-numbers","depth":3,"charIndex":1307},{"text":"Wrap Code","id":"wrap-code","depth":3,"charIndex":1430},{"text":"Line Highlighting","id":"line-highlighting","depth":3,"charIndex":1555},{"text":"Rustify MDX compiler","id":"rustify-mdx-compiler","depth":2,"charIndex":1686}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"React-Hook 使用指南","content":"#\n\nHook可以帮助在组件中使用不同的React功能。 你可以使用内置的Hook或使用自定义Hook\n\n\nuseCallback#\n\nuseCallback是一个允许你在多次渲染中缓存函数的React Hook\n\n * 用法\n   \n   * 跳过组件的重新渲染\n   \n   * 从记忆化回调中更新state\n   \n   * 防止频繁出发Effect\n   \n   * 优化自定义Hook\n\n\n\n参数\n\n> fn：想要缓存的函数。此函数可以接受任何参数并且返回任何值。在初次渲染时，React 将把函数返回给你（而不是调用它！）。当进行下一次渲染时，如果\n> dependencies 相比于上一次渲染时没有改变，那么 React 将会返回相同的函数。否则，React\n> 将返回在最新一次渲染中传入的函数，并且将其缓存以便之后使用。React 不会调用此函数，而是返回此函数。你可以自己决定何时调用以及是否调用。\n\n> dependencies：有关是否更新 fn 的所有响应式值的一个列表。响应式值包括\n> props、state，和所有在你组件内部直接声明的变量和函数。如果你的代码检查工具 配置了\n> React，那么它将校验每一个正确指定为依赖的响应式值。依赖列表必须具有确切数量的项，并且必须像 [dep1, dep2, dep3] 这样编写。React\n> 使用 Object.is 比较每一个依赖和它的之前的值。\n\n\nuseRequest#\n\nuseRequest 是一个强大的异步数据管理的 Hooks，React 项目中的网络请求场景使用 useRequest 就够了。详细参考\n\n主要功能\n\n\n\n参数\n\n\n\nResult\n\n参数             说明\ndata           service 返回的数据\nerror          service 抛出的异常\nloading        service 是否正在执行\nparams         当次执行的 service 的参数数组。比如你触发了 run(1, 2, 3)，则 params 等于 [1, 2,\n               3]\nrun            手动触发 service 执行，参数会传递给 service 异常自动处理，通过 onError 反馈\nrunAsync       与 run 用法一致，但返回的是 Promise，需要自行处理异常。\nrefresh        使用上一次的 params，重新调用 run\nrefreshAsync   使用上一次的 params，重新调用 runAsync\nmutate         直接修改 data\ncancel         忽略当前 Promise 的响应\n\nOptions\n\n参数              说明\nmanual          默认 false。 即在初始化时自动执行 service。如果设置为 true，则需要手动调用 run 或\n                runAsync 触发执行。\ndefaultParams   首次默认执行时，传递给 service 的参数\nonBefore        service 执行前触发\nonSuccess       service resolve 时触发\nonError         service reject 时触发\nonFinally       service 执行完成时触发\n\n\nReact.memo避免组件的重新渲染#\n\n一半来讲一下三种情况需要重新渲染组件：\n\n 1. 组件内部 state 发生变化时\n 2. 组件内部使用的 context 发生变化时\n 3. 组件外部传递的 props 发生变化时\n\n","routePath":"/note/reactHook","lang":"","toc":[{"text":"useCallback","id":"usecallback","depth":2,"charIndex":53},{"text":"useRequest","id":"userequest","depth":2,"charIndex":619},{"text":"React.memo避免组件的重新渲染","id":"reactmemo避免组件的重新渲染","depth":2,"charIndex":1483}],"domain":"","frontmatter":{},"version":""}]